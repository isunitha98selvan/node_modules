import { animationFrame } from "rxjs/scheduler/animationFrame";
import { asap } from "rxjs/scheduler/asap";
import { async } from "rxjs/scheduler/async";
import { queue } from "rxjs/scheduler/queue";
import { argsSymbol } from "./args";
import { assertArgs, assertSubscriptions } from "./assert";
import { configure } from "./configuration";
import { Expect } from "./expect";
var Context = (function () {
    function Context(scheduler) {
        this.scheduler = scheduler;
        this.autoFlush = true;
        this.configure = configure;
        this.bindings_ = [];
    }
    Context.prototype.bind = function () {
        var _this = this;
        var schedulers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            schedulers[_i] = arguments[_i];
        }
        if (this.bindings_.length !== 0) {
            throw new Error("Schedulers already bound.");
        }
        if (schedulers.length === 0) {
            schedulers = [animationFrame, asap, async, queue];
        }
        this.bindings_ = schedulers.map(function (instance) {
            var now = instance.hasOwnProperty("now") ? instance.now : undefined;
            instance.now = function () { return _this.scheduler.now(); };
            var schedule = instance.hasOwnProperty("schedule") ? instance.schedule : undefined;
            instance.schedule = function (work, delay, state) { return _this.scheduler.schedule(work, delay, state); };
            return { instance: instance, now: now, schedule: schedule };
        });
    };
    Context.prototype.cold = function (marbles, values, error) {
        var scheduler = this.scheduler;
        var observable = scheduler.createColdObservable(marbles, values, error);
        observable[argsSymbol] = { error: error, marbles: marbles, values: values };
        return observable;
    };
    Context.prototype.equal = function (actual) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var scheduler = this.scheduler;
        var a0 = args[0], a1 = args[1], a2 = args[2], a3 = args[3];
        if (a1 && (typeof a1 === "string")) {
            scheduler.expectObservable(actual, a0).toBe(a1, a2, a3);
        }
        else if (a1 && a1[argsSymbol]) {
            assertArgs(a1);
            var _a = a1[argsSymbol], error = _a.error, marbles = _a.marbles, values = _a.values;
            scheduler.expectObservable(actual, a0).toBe(marbles, values, error);
        }
        else if (typeof a0 === "string") {
            scheduler.expectObservable(actual).toBe(a0, a1, a2);
        }
        else {
            assertArgs(a0);
            var _b = a0[argsSymbol], error = _b.error, marbles = _b.marbles, values = _b.values;
            scheduler.expectObservable(actual).toBe(marbles, values, error);
        }
    };
    Context.prototype.expect = function (actual, unsubscription) {
        var scheduler = this.scheduler;
        return new Expect(actual, scheduler, unsubscription);
    };
    Context.prototype.flush = function () {
        var scheduler = this.scheduler;
        scheduler.flush();
    };
    Context.prototype.has = function (actual, expected) {
        assertSubscriptions(actual);
        var scheduler = this.scheduler;
        scheduler.expectSubscriptions(actual.subscriptions).toBe(expected);
    };
    Context.prototype.hot = function (marbles, values, error) {
        var scheduler = this.scheduler;
        var observable = scheduler.createHotObservable(marbles, values, error);
        observable[argsSymbol] = { error: error, marbles: marbles, values: values };
        return observable;
    };
    Context.prototype.teardown = function () {
        if (this.autoFlush) {
            this.scheduler.flush();
        }
        this.bindings_.forEach(function (_a) {
            var instance = _a.instance, now = _a.now, schedule = _a.schedule;
            if (now) {
                instance.now = now;
            }
            else {
                delete instance.now;
            }
            if (schedule) {
                instance.schedule = schedule;
            }
            else {
                delete instance.schedule;
            }
        });
    };
    Context.prototype.time = function (marbles) {
        var scheduler = this.scheduler;
        return scheduler.createTime(marbles);
    };
    return Context;
}());
export { Context };
